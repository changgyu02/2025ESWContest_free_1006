import rclpy
from rclpy.node import Node
from std_srvs.srv import SetBool
import torch
from torchvision import transforms
import cv2
from PIL import Image

class DirtCheckNode(Node):
    def __init__(self):
        super().__init__('dirt_check_node')

        self.declare_parameter('model_path', 'model/dirt_classifier.pt')
        model_path = self.get_parameter('model_path').get_parameter_value().string_value

        # í´ë˜ìŠ¤ ì´ë¦„ ì •ì˜
        self.class_names = ['clean_table', 'dirty_table']

        # ëª¨ë¸ ë¡œë“œ
        self.model = torch.load(model_path, map_location=torch.device('cpu'))
        self.model.eval()

        # ì „ì²˜ë¦¬ ì •ì˜
        self.transform = transforms.Compose([
            transforms.Resize((640, 640)),
            transforms.ToTensor(),
        ])

        # ì›¹ìº  ì´ˆê¸°í™”
        self.cap = cv2.VideoCapture(0)
        if not self.cap.isOpened():
            self.get_logger().error('âŒ ì¹´ë©”ë¼ ì—´ê¸° ì‹¤íŒ¨')
            exit()

        # ì„œë¹„ìŠ¤ ì„œë²„ ìƒì„±
        self.srv = self.create_service(SetBool, 'dirt_check_service', self.handle_dirt_check)
        self.get_logger().info('ğŸ§ª dirt_check_node ì‹œì‘ (ì„œë¹„ìŠ¤ ì„œë²„ ê¸°ë°˜)')

    def handle_dirt_check(self, request, response):
        self.get_logger().info('ğŸ“¥ ì˜¤ì—¼ë„ íŒë‹¨ ìš”ì²­ ìˆ˜ì‹ ')

        ret, frame = self.cap.read()
        if not ret:
            self.get_logger().error('âŒ ì¹´ë©”ë¼ í”„ë ˆì„ ì½ê¸° ì‹¤íŒ¨')
            response.success = False
            response.message = 'í”„ë ˆì„ ì½ê¸° ì‹¤íŒ¨'
            return response

        # OpenCV â†’ PIL ë³€í™˜
        image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        image = Image.fromarray(image)

        # ì „ì²˜ë¦¬ í›„ ëª¨ë¸ ì¶”ë¡ 
        input_tensor = self.transform(image).unsqueeze(0)  # [1, 3, 640, 640]
        with torch.no_grad():
            outputs = self.model(input_tensor)
            probabilities = torch.nn.functional.softmax(outputs[0], dim=0)
            predicted_idx = torch.argmax(probabilities).item()
            predicted_label = self.class_names[predicted_idx]
            confidence = probabilities[predicted_idx].item()

        # íŒë‹¨ ê²°ê³¼ ì¶œë ¥
        self.get_logger().info(f'ğŸ” ë¶„ë¥˜ ê²°ê³¼: {predicted_label} ({confidence*100:.2f}%)')

        response.success = (predicted_label == 'dirty_table')  # Trueì´ë©´ ë”ëŸ½ë‹¤ëŠ” ì˜ë¯¸
        response.message = f'{predicted_label} ({confidence*100:.2f}%)'
        return response

    def destroy_node(self):
        self.cap.release()
        super().destroy_node()

def main(args=None):
    rclpy.init(args=args)
    node = DirtCheckNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        node.get_logger().info('ğŸ›‘ ì¢…ë£Œ ìš”ì²­ ìˆ˜ì‹ ')
    node.destroy_node()
    rclpy.shutdown()
